<html>
<head>
    <% include template/header %>
    <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
    <script src="js/heatmap/build/heatmap.js"></script>
    <script src='js/heatmap/plugins/leaflet-heatmap-revision.js'></script>
    <script src="js/ion.rangeSlider-2.0.6/js/ion-rangeSlider/ion.rangeSlider.js"></script>
</head>
<body>
    <% include template/navbar %>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
    <link rel="stylesheet" href="js/ion.rangeSlider-2.0.6/css/normalize.css" type="text/css" />
    <link rel="stylesheet" href="js/ion.rangeSlider-2.0.6/css/ion.rangeSlider.css" type="text/css" />
    <link rel="stylesheet" href="js/ion.rangeSlider-2.0.6/css/ion.rangeSlider.skinHTML5.css" type="text/css" />
    <div class="container-fluid" style="height:75%; padding-left:130px; padding-right:130px;">
        <div class="row">
            <div class="col-sm-9">
                <div id = 'map'></div>
            </div>
            <div class="col-sm-3">
                <div id="beacons" ng-app="heatmapApp" ng-controller="BeaconListCtrl">
                  <input type="text" id="query" ng-model="query"/>
                  <select ng-model="orderList">
                    <option value="Name">By name</option>
                    <option value="-Date">Newest</option>
                    <option value="Date">Oldest</option>
                  </select>
                  <ul id="beacon_ul" class="list">
                    <li ng-repeat="beacon in beacons | filter:query | orderBy: orderList" class="list">
                      <strong>Name: </strong><div class="right">{{beacon.Name}}</div><br>
                      <strong>Date added: </strong><div class="right">{{beacon.Date}}</div><br>
                      <strong>Coord: </strong><div class="right">{{beacon.Coord}}</div><br><!-- </div> -->
                    </li>
                  </ul>
                  <span>Number of beacons: {{beacons.length}}</span>
                </div>
            </div>
        </div>
    </div>

    <div id = "style">
        <div id = "dateSlider";></div>
    </div>

    <% include template/footer %>
</body>
<script>

    var heatmapModule = angular.module('heatmapApp', []);

    heatmapModule.factory('beaconService', function($http) {
       return {
            getBeacons: function() {
                 //return the promise directly.
                 return $http.get('/heatmap/retrieveBeaconsJSON')
                           .then(function(result) {
                                //resolve the promise as the data
                                return result.data;
                            });
            }
       }
    });

    heatmapModule.controller('BeaconListCtrl', function($scope, beaconService) {
        beaconService.getBeacons().then(function(beaconList) {
            beacons = [];
            for (var i in beaconList) {
                var coordY = beaconList[i].coordY;
                var coordX = beaconList[i].coordX;
                var beacon = {
                    "Name": beaconList[i].name,
                    "Date": moment(beaconList[i].createdAt).format('YYYY/MM/DD'),
                    "Coord": [coordX, coordY]
                };
                            console.log(beacon)
                beacons.push(beacon);
            }
            $scope.beacons = beacons;
            $scope.orderList = "name";
        });
    });

    var w = 1280,
    h = 777,
    imageUrl = "/img/floorplan.jpg";
    NORMALIZE_COEF = 4;
    Y_SCALING = 0;
    X_SCALING = 0;
    var beaconList = [];
    //heatmap.js config
    var cfg = {
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
        // if scaleRadius is false it will be the constant radius used in pixels
        maxOpacity: 0.6,
        radius: 4,
        blur: .90,
        // scales the radius based on map zoom
        "scaleRadius": true, 
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries 
        //   (there will always be a red spot with useLocalExtremas true)
        "useLocalExtrema": false,
        // which field name in your data represents the latitude - default "lat"
        latField: 'y',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'x',
        // which field name in your data represents the data value - default "value"
        valueField: 'value'
    };

    var heatmapLayer = new HeatmapOverlay(cfg);

    //setup map
    var map = new L.map('map', {
        minZoom: 2,
        maxZoom: 4,
        center: [0, 0],
        zoom: 1,
        crs: L.CRS.Simple,
        layers: [heatmapLayer]
    });

    var southWest = map.unproject([-(w/2), h/2], map.getMaxZoom()-1);
    var northEast = map.unproject([w/2, -(h/2)], map.getMaxZoom()-1);
    var imageBounds = new L.LatLngBounds(southWest, northEast);
    var imageLayer = L.imageOverlay(imageUrl, imageBounds);
    imageLayer.addTo(map);
    //tell leaflet that the map is exactly as big as the image
    map.setMaxBounds(imageBounds);
    imageLayer.bringToBack();

    function retrieveBeacons(){
        $.get('/heatmap/retrieveBeaconsJSON')
        .success(function (rawData) {
            //add beacons to map
            console.log(rawData);
            for (var i in rawData) {
                var coordY = rawData[i].coordY;
                var coordX = rawData[i].coordX;
                var beacon = L.marker([coordY*NORMALIZE_COEF, coordX*NORMALIZE_COEF]).addTo(map);
                beacon.bindPopup("<b>"+ rawData[i].name +"</b><br>[ " + coordY + ", " + coordX + " ]");
            }
        });
    }

    retrieveBeacons();
    console.log(map.getBounds());
    console.log(imageBounds);
    // map.fitBounds(imageBounds, {padding: []});
    // map.fitWorld(imageBounds, {padding: []});

    //get json from Parse
    $.get('/heatmap/retrieveIntervalRecordsJSON')
    .success(function (rawData) {
        var dateHash = {};
        var refreshIntervalId;
        var countArray = [],
        intervalCounter = 10,
        index = 0,
        data = {
            max:15,
            min:0,
            data:[]
        };

        //console.log(rawData);
        for (var i in rawData) {
            rawData[i].forEach(function(elem, elemIndex) {
                //console.log(elem, elemIndex);
                elem.value = 0;
                elem.fresh = true;
                if(elem.coordX && elem.coordY && elem.timestamp && (elem.timestamp.__type == 'Date')) {
                    elem.x = parseFloat((elem.coordX*NORMALIZE_COEF)-X_SCALING);
                    elem.y = parseFloat((elem.coordY*NORMALIZE_COEF)-Y_SCALING);
                    elem.date = moment(elem.timestamp.iso);
                    var dateStr = moment(elem.timestamp.iso).format('MM/DD/YYYY');
                    // check for preexisting data for a date
                    if(dateStr in dateHash) {
                        dateHash[dateStr].push(elem);
                    }
                    else {
                        var goodData = [];
                        goodData.push(elem);
                        dateHash[dateStr] = goodData;
                    }
                }
            });
        }

        var today = moment().startOf('day');
        var prevDate = moment(today);
        prevDate.subtract(7, "days");

        console.log(dateHash);
        console.log("Timeline Min: " + today);
        console.log("Timeline Max: " + prevDate);

        function animateData() {
            //iterates n times for each day
            var pollingRate = 15;

            if (intervalCounter == pollingRate)
            {
                intervalCounter = 0;
                if (nextDate <= today) {
                    getAnotherDay();
                }
            }
            else
            {
                intervalCounter++;
            }
            //create new array for live points, push it to the map
            var newData = [];
            for (var j = 0; j < data.data.length; j++) {
                var point = data.data[j];
                if (point.value >= pollingRate) {
                    point.fresh = false;
                }
                //fade in fresh points, fade out unfresh points
                if (point.fresh)
                {
                    point.value = point.value + 2;
                }
                else
                {
                    point.value = point.value - .8;
                }
                if(point.value > 0)
                {
                    newData.push(data.data[j]);
                }
            }
            data.data = newData;
            // push new daily data into heatmap layer
            //console.log(data);
            heatmapLayer.setData(data);
            heatmapLayer._heatmap.setData(data);
            heatmapLayer._update();
        }

        function showData(newData){
            console.log(newData);
            for (var i = 0; i < newData.length; i++) {
                var point = newData[i];
                    point.value = 20;
                    point.fresh = true;
            }
            if (newData.length != 0)
            {
                data.data = newData
                heatmapLayer.setData(data);
            }
            else
            {
                data.data = newData
                heatmapLayer.setData(data);
                heatmapLayer._heatmap.setData(data);
                heatmapLayer._update();
            }
        }

        $("#dateSlider").ionRangeSlider({
            min: +prevDate.format("X"),
            max: +today.format("X"),
            grid: true,
            grid_num: 7,
            prettify_enabled: true,
            prettify: function (num) {
                return moment(num, "X").format("LL");
            },
            onChange: function (data) {
                if (refreshIntervalId != null){
                    clearInterval(refreshIntervalId);
                }
            },
            onFinish: function (data) {
                nextDate = moment.unix(data.from).startOf('day');
                var selectedDateKey = nextDate.format('MM/DD/YYYY');
                console.log("Selected: " + selectedDateKey);
                var newData = [];
                if (selectedDateKey in dateHash) {
                    newData = dateHash[selectedDateKey];
                }
                showData(newData);
            },
        });

        // Save slider instance to var
        var slider = $("#dateSlider").data("ionRangeSlider");

        // heatmapLayer.setData(data);
        var nextDate = prevDate;

        //refresh every 100 milliseconds
        refreshIntervalId = setInterval(animateData, 100);

        function getAnotherDay() {
            // Call sliders update method with any params
            slider.update({
                from: +nextDate.format("X")
            });
            console.log("Current Date: " + nextDate);
            var todayCounter = 0;

            //iterate over goodData, push today's events to data.data
            // var thisDate = goodData[index].date;
            var nextDateKey = nextDate.format('MM/DD/YYYY');
            console.log(nextDateKey);
            if(nextDateKey in dateHash) {
                data.data = data.data.concat(dateHash[nextDateKey]);
                todayCounter = dateHash[nextDateKey].length;
                prevDate = nextDate;
            }
            var todayCount = {
                date:prevDate,
                count:todayCounter
            };
            countArray.push(todayCount);

            nextDate = moment(nextDate).add(1, "days");
        }
    });

</script>
</html>
